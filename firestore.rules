/**
 * Core Philosophy: This ruleset implements a security model based on user roles and data ownership.
 * It establishes a clear distinction between standard users and privileged administrators. Standard
 * users have control over their own data (like their user profile and SOS alerts), while administrators
 * have exclusive access to system-wide collections like incident reports. Security guards have the
 * specific ability to create incidents, but cannot view the full collection.
 *
 * Data Structure:
 * - /users/{userId}: Private user profiles, only accessible by the owner. Contains a 'role' field.
 * - /incidents/{incidentId}: Sensitive reports. Guards can create them, but only administrators can read/manage them.
 * - /appointments/{appointmentId}: Collaborative documents shared between two specific users (a student and staff member).
 * - /sos_alerts/{sosAlertId}: User-owned emergency alerts, which are also visible to administrators for safety monitoring.
 *
 * Key Security Decisions:
 * - Admin-Only Manage for Incidents: The '/incidents' collection is locked down for management (update/delete) to users
 *   with the 'administrator' role, enforcing strict confidentiality.
 * - Guard-Specific Create for Incidents: Users with the 'guard' role are granted permission to create new incident reports.
 * - Shared Ownership: Appointments in '/appointments' are accessible only to the two participants defined in the document,
 *   enabling collaborative but private scheduling.
 * - Default Deny: Access is denied by default. Rules are written to explicitly grant permissions based on defined logic.
 * - Domain Restriction: User creation is restricted to emails ending in '@hitam.org'.
 *
 * Denormalization for Authorization:
 * - A 'role' field is stored directly on each document in the '/users' collection. This avoids costly cross-collection `get()`
 *   calls in most rules and allows for a simple, performant role check.
 * - Appointment documents contain 'studentId' and 'staffId' fields, allowing rules to authorize access without needing to look up
 *   related documents.
 * - SOS alerts contain a 'uid' field, which directly links the alert to its owner for straightforward ownership checks.
 *
 * Structural Segregation:
 * - Sensitive data (incidents) is placed in a separate top-level collection, '/incidents'.
 *   This makes it simple to write secure rules that segregate create and manage permissions based on role.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------
    // Helper Functions
    // --------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's ID matches the provided userId.
     * This is the primary function for enforcing data ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if a document already exists.
     * CRITICAL for safe update and delete operations.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Checks if the requesting user has the 'administrator' role.
     * This performs a single document read to the user's own profile to check their role.
     */
    function isAdmin() {
      return isSignedIn() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'administrator';
    }

    /**
     * Checks if the requesting user has the 'guard' role.
     */
    function isGuard() {
      return isSignedIn() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'guard';
    }

     /**
     * Checks if the requesting user has the 'student' role.
     */
    function isStudent() {
      return isSignedIn() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'student';
    }

    /**
     * Checks if the requesting user is a parent of the given studentId.
     */
    function isParentOf(studentId) {
      // Ensure childrenUids exists before trying to access it.
      return isSignedIn() &&
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             'childrenUids' in get(/databases/$(database)/documents/users/$(request.auth.uid)).data &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.childrenUids.hasAny([studentId]);
    }

    /**
     * Checks if the requesting user is a participant in the given appointment.
     * An appointment is a collaborative document between a student and a staff member.
     */
    function isAppointmentParticipant(appointmentData) {
      return isSignedIn() && (request.auth.uid == appointmentData.studentId || request.auth.uid == appointmentData.staffId);
    }

    // --------------------------------
    // Collection Rules
    // --------------------------------

    /**
     * @description Users can create and manage their own profile information. Admins can manage all profiles.
     * @path /users/{userId}
     * @allow (create) An authenticated user (uid: 'user123') with a 'hitam.org' email creates their own profile at `/users/user123`.
     * @allow (update) Admin 'admin123' updates the role of user 'user456'.
     * @allow (delete) Admin 'admin123' deletes the profile of 'user456'.
     * @deny (create) A user with a 'gmail.com' email tries to create a profile.
     * @deny (update) User 'user123' tries to update the profile of 'user456'.
     * @principle Restricts access to a user's own data tree and enforces domain policy, while giving admins full control.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin(); // Admins can view profiles too
      allow list: if isSignedIn();
      allow create: if isOwner(userId) && request.resource.data.uid == userId && request.resource.data.email.matches('.*@hitam\\.org$');
      allow update: if isOwner(userId) || isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Security guards or students can create incident reports. Only administrators and involved parties can view them.
     * @path /incidents/{incidentId}
     * @allow (create) A user with the 'guard' or 'student' role creates a new incident report.
     * @allow (list) Any signed-in user lists documents in the 'incidents' collection.
     * @allow (delete) An admin deletes a specific incident report.
     * @deny (get) A non-admin user (unless they are a reporter or involved party) attempts to read a specific incident report.
     * @deny (delete) A non-admin user attempts to delete an incident report.
     * @principle Enforces strict Role-Based Access Control (RBAC), separating create and manage permissions.
     */
    match /incidents/{incidentId} {
      allow get: if isAdmin() || isOwner(resource.data.reporterId) || isOwner(resource.data.targetStudentId) || isParentOf(resource.data.targetStudentId);
      allow list: if isSignedIn();
      allow create: if isGuard() || isAdmin() || (isStudent() && request.resource.data.reporterId == request.auth.uid);
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Access to an appointment is restricted to its participants (student and staff).
     * @path /appointments/{appointmentId}
     * @allow (get) The user identified by 'studentId' reads their own appointment document.
     * @deny (get) A third-party user, not listed as 'studentId' or 'staffId', tries to read an appointment.
     * @principle Implements a "Shared Access" model for collaborative documents.
     */
    match /appointments/{appointmentId} {
      allow get: if isAppointmentParticipant(resource.data);
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.studentId == request.auth.uid;
      allow update: if isExistingDoc() && isAppointmentParticipant(resource.data);
      allow delete: if isExistingDoc() && isAppointmentParticipant(resource.data);
    }

    /**
     * @description Users can create their own SOS alerts, and administrators can view all alerts for safety monitoring.
     * @path /sos_alerts/{sosAlertId}
     * @allow (create) A user creates an SOS alert, setting their own 'uid' in the document.
     * @deny (update) A user attempts to update an SOS alert that was created by another user.
     * @principle Enforces document ownership for writes, with privileged read access for administrators.
     */
    match /sos_alerts/{sosAlertId} {
      allow get: if isOwner(resource.data.uid) || isAdmin();
      allow list: if isAdmin(); // Only admins can list all alerts; users must query for their own.
      allow create: if isSignedIn() && request.resource.data.uid == request.auth.uid;
      allow update: if isExistingDoc() && isOwner(resource.data.uid);
      allow delete: if isExistingDoc() && isOwner(resource.data.uid);
    }
  }
}
